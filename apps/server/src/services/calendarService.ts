import OpenAI from 'openai';

import { config } from '../config';
import { logger } from '../logger';
import { memoryService } from './memoryService';

export type CalendarEvent = {
  id: string;
  title: string;
  startDate: string;
  endDate?: string;
  location?: string;
  notes?: string;
  attendees?: string[];
  isAllDay?: boolean;
  calendarName?: string;
  timeZone?: string;
};

class CalendarService {
  /**
   * Generate journal entry from calendar event using AI
   */
  async generateEntryFromEvent(
    userId: string,
    event: CalendarEvent
  ): Promise<{ id: string; content: string; tags: string[] } | undefined> {
    try {
      // Build context from event
      const contextParts: string[] = [];
      
      contextParts.push(`Event: ${event.title}`);
      
      if (event.location) {
        contextParts.push(`Location: ${event.location}`);
      }
      
      if (event.startDate) {
        const startDate = new Date(event.startDate);
        contextParts.push(`Date: ${startDate.toLocaleDateString()}`);
        contextParts.push(`Time: ${startDate.toLocaleTimeString()}`);
      }
      
      if (event.endDate) {
        const endDate = new Date(event.endDate);
        const duration = Math.round((endDate.getTime() - new Date(event.startDate).getTime()) / (1000 * 60));
        if (duration > 0) {
          contextParts.push(`Duration: ${duration} minutes`);
        }
      }
      
      if (event.attendees && event.attendees.length > 0) {
        contextParts.push(`With: ${event.attendees.join(', ')}`);
      }
      
      if (event.notes) {
        contextParts.push(`Notes: ${event.notes}`);
      }
      
      if (event.calendarName) {
        contextParts.push(`Calendar: ${event.calendarName}`);
      }

      const context = contextParts.join('\n');

      // Use GPT to generate a journal entry description
      const prompt = `Based on this calendar event, create a brief journal entry describing what happened or what's planned. Be natural and concise. Focus on the experience and context.

${context}

Generate a journal entry:`;

      const openaiClient = new OpenAI({ apiKey: config.openAiKey });
      
      const completion = await openaiClient.chat.completions.create({
        model: config.defaultModel,
        temperature: 0.7,
        messages: [
          {
            role: 'system',
            content: 'You are a journaling assistant. Create brief, natural journal entries from calendar events. Include location, date, attendees, and context if available.'
          },
          {
            role: 'user',
            content: prompt
          }
        ]
      });

      const summary = completion.choices[0]?.message?.content || `${event.title}${event.location ? ` at ${event.location}` : ''}`;

      // Extract tags from event
      const tags: string[] = ['calendar', 'event'];
      
      if (event.location) {
        tags.push('location');
        // Extract city/place name as tag
        const placeParts = event.location.split(',');
        if (placeParts.length > 0) {
          tags.push(placeParts[0].toLowerCase().replace(/\s+/g, '-'));
        }
      }
      
      if (event.attendees && event.attendees.length > 0) {
        tags.push('with-others', 'meeting');
      }
      
      // Add calendar name as tag if available
      if (event.calendarName) {
        tags.push(event.calendarName.toLowerCase().replace(/\s+/g, '-'));
      }

      // Save auto-generated entry
      const entry = await memoryService.saveEntry({
        userId,
        content: summary,
        date: event.startDate,
        tags,
        source: 'calendar',
        metadata: {
          calendarEvent: {
            id: event.id,
            title: event.title,
            location: event.location,
            attendees: event.attendees,
            isAllDay: event.isAllDay,
            calendarName: event.calendarName
          },
          autoGenerated: true,
          fromCalendar: true
        }
      });

      return {
        id: entry.id,
        content: summary,
        tags
      };
    } catch (error) {
      logger.error({ error, eventId: event.id }, 'Failed to generate entry from calendar event');
      return undefined;
    }
  }

  /**
   * Sync calendar events and create journal entries
   */
  async syncEvents(
    userId: string,
    events: CalendarEvent[]
  ): Promise<{ entriesCreated: number; totalProcessed: number; entries: Array<{ id: string; content: string; tags: string[] }> }> {
    const results = await Promise.all(
      events.map(async (event) => {
        const entry = await this.generateEntryFromEvent(userId, event);
        return {
          eventId: event.id,
          entry,
          skipped: !entry
        };
      })
    );

    const entriesCreated = results.filter(r => r.entry).length;
    const entries = results.map(r => r.entry).filter(Boolean) as Array<{ id: string; content: string; tags: string[] }>;

    logger.info({ 
      entriesCreated, 
      total: events.length, 
      userId 
    }, 'Calendar events synced and entries created');

    return {
      entriesCreated,
      totalProcessed: events.length,
      entries
    };
  }
}

export const calendarService = new CalendarService();

